task:
enter and output a string
code:
#include <stdio.h>
int main()
{		
	char string[100];
	
	printf("enter the string > ");
	
	fgets(string, sizeof(string), stdin);
	
	
	printf("output > ");
	
	printf("%s", string);
	
	return 0;
}
output:
enter the string > ABC abc 123
output > ABC abc 123

task:
print the version of program using a preprocessor
code:
#include <stdio.h>

#define VERSION printf("version 3.56.4 \n");

int main()
{		
	VERSION;
	
	return 0;
}
output:
version 3.56.4

task:
finish the program ahead of schedule
exit(EXIT_SUCCESS) - uses stdlib.h
code:
#include <stdio.h>
#include <stdlib.h>

int main()
{		
	printf("program shutdown...");
	
	exit(EXIT_SUCCESS);

	
	printf("text...");
	
	return EXIT_SUCCESS;
}
output:
program shutdown...

task:
exit the program using the "exit" command
fgets - saves a string with a character '\n'
strcmp - compares strings
code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define PROMPT printf("db > ");
char command[100];

int main()
{		
	PROMPT;
	
	fgets(command, sizeof(command), stdin);
	
	if( strcmp(command, "exit\n") == 0 )
	{
		printf("program shutdown... \n");
		exit(EXIT_SUCCESS);
	}
	else
	{
		printf("command unknown \n");
	}
	
	return EXIT_SUCCESS;
}
output:
db > exit
program shutdown...

task:
use true and false. instead of 1 and 0
code:
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int main()
{		
	if(true)
	{
		printf("true");
	}
	
	if(false)
	{
		printf("false");
	}
	
	return EXIT_SUCCESS;
}
output:
true

task:
compare the first characters of two strings
code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{		
	char one[9] = "123456789";
	char two[9] = "123455555";
	
	if( strncmp(one, two, 5) == 0 )
	{
		printf("first 5 characters are equal \n");
	}
	
	if( strncmp(one, two, 6) == 0 )
	{
		printf("first 6 characters are equal \n");
	}
	else
	{
		printf("first 6 characters are not equal \n");
	}
	
	return EXIT_SUCCESS;
}
output:
first 5 characters are equal
first 6 characters are not equal

task:
endless loop of command input
add select and insert commands
end the program only after entering the "exit" command 
code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define PROMPT printf("db > ");
char command[100];

int main()
{		
	while(true)
	{
		PROMPT;
	
		fgets(command, sizeof(command), stdin);
	
	
		if( strncmp(command, "select", 6) == 0 )
		{
			printf("data selection... \n");
		}
		else if( strncmp(command, "insert", 6) == 0 )
		{
			printf("data insertion... \n");
		}
		else if( strcmp(command, "exit\n") == 0 )
		{
			printf("program shutdown... \n");
			exit(EXIT_SUCCESS);
		}
		else
		{
			printf("command unknown \n");
		}
	}
	
	return EXIT_SUCCESS;
}
output:
db > insert ABC
data insertion...
db > select 123
data selection...
db > help
command unknown
db > exit
program shutdown...

task:
read the necessary parts of string
code:
#include <stdio.h>
#include <stdlib.h>

int main()
{		
	int number;
	char str_one[10];
	char str_two[10];
	
	char string[] = "text 15 Aaa Bbb ZZZ";
	
	sscanf(string, "text %d %s %s ZZZ", &number, str_one, str_two);
	
	
	printf("%d, %s, %s \n", number, str_one, str_two);
	
	return EXIT_SUCCESS;
}
output:
15, Aaa, Bbb

task:
use the "insert" command to save data
use the "select" command to print all users
code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define PROMPT printf("db > ");
char command[100];

typedef struct
{
	int id;
	char name[32];
	char email[255];
} User;

User user[100];
int user_num = 0;

void add_user()
{	
	sscanf(command, "insert %d %s %s \n", &user[user_num].id, user[user_num].name, user[user_num].email);
	
	user_num++;
}

void print_all_users()
{
	int i;
	
	for(i = 0; user_num > i; i++)
	{
		printf("%d, %s, %s \n", user[i].id, user[i].name, user[i].email);
	}
}

int main()
{		
	while(true)
	{
		PROMPT;
	
		fgets(command, sizeof(command), stdin);
	
	
		if( strncmp(command, "select", 6) == 0 )
		{
			print_all_users();
			printf("data selection completed... \n");
		}
		else if( strncmp(command, "insert", 6) == 0 )
		{
			add_user();
			printf("data insertion completed... \n");
		}
		else if( strcmp(command, "exit\n") == 0 )
		{
			printf("program shutdown... \n");
			exit(EXIT_SUCCESS);
		}
		else
		{
			printf("command unknown \n");
		}
	}
	
	return EXIT_SUCCESS;
}
output:
db > insert 1 Aaaa aaa@aa.aa
data insertion completed...
db > insert 2 Bbbb bbb@bb.bb
data insertion completed...
db > select
1, Aaaa, aaa@aa.aa
2, Bbbb, bbb@bb.bb
data selection completed...
db > exit
program shutdown...

task:
break a string into words
code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{		
	char string[] = "AAA  BBB,CCC.DDD";
	char delimiters[] = " ,.";
	char *pointer;
	
	pointer = strtok(string, delimiters);
	
	while(pointer != NULL)
	{
		printf("%s \n", pointer);
		
		pointer = strtok(NULL, delimiters);
	}
	
	return EXIT_SUCCESS;
}
output:
AAA
BBB
CCC
DDD

task:
convert string to number
code:
#include <stdio.h>
#include <stdlib.h>

int main()
{		
	char one[] = "50";
	char two[] = "4";
	int num;
	
	num = atoi(one) + atoi(two);
	
	printf("num = %d", num);
	
	return EXIT_SUCCESS;
}
output:
num = 54

task:
replace character in string
strcspn() - returns string length from begin to first character found
code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{		
	char string[] = "AAABAAA";
	char symbol[] = "B";
	int num;
	
	num = strcspn(string, symbol);
	
	printf("string length to character 'B' = %d \n", num);
	
	
	string[num] = 'A';
	
	printf("%s \n", string);
	
	
	return EXIT_SUCCESS;
}
output:
length to character 'B' = 3
AAAAAAA

task:
add user only if the entered arguments 
"insert" command are not empty and have a valid length
code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define PROMPT printf("db > ");
#define NAME_SIZE 32
#define EMAIL_SIZE 255
char command[100];

typedef struct
{
	int id;
	char name[NAME_SIZE];
	char email[EMAIL_SIZE];
} User;

User user[100];
int user_num = 0;

void add_user()
{	
	char *keyword = strtok(command, " ");
	char *id = strtok(NULL, " ");
	char *name = strtok(NULL, " ");
	char *email = strtok(NULL, " ");
	
	if(id == NULL || name == NULL || email == NULL)
	{
		printf("syntax error \n");
	}
	else
	{
		if( strlen(name) > NAME_SIZE )
		{
			printf("name is more than 32 bytes \n");
		}
		else if( strlen(email) > EMAIL_SIZE )
		{
			printf("email is more than 255 bytes \n");
		}
		else
		{
			user[user_num].id = atoi(id);
			strcpy(user[user_num].name, name);
			strcpy(user[user_num].email, email);
			
			user_num++;
			
			printf("data insertion completed... \n");
		}
	}
	
}

void print_all_users()
{
	int i;
	
	for(i = 0; user_num > i; i++)
	{
		printf("%d, %s, %s \n", user[i].id, user[i].name, user[i].email);
	}
}

int main()
{		
	while(true)
	{
		PROMPT;
	
		fgets(command, sizeof(command), stdin);
		/* remove '\n' from input data fgets() */
		command[strcspn(command, "\n")] = 0;
	
		if( strncmp(command, "select", 6) == 0 )
		{
			print_all_users();
			printf("data selection completed... \n");
		}
		else if( strncmp(command, "insert", 6) == 0 )
		{
			add_user();
		}
		else if( strcmp(command, "exit") == 0 )
		{
			printf("program shutdown... \n");
			exit(EXIT_SUCCESS);
		}
		else
		{
			printf("command unknown \n");
		}
	}
	
	return EXIT_SUCCESS;
}
output:
db > insert 1 Aaa aaa@aa.aa
data insertion completed...
db > insert 2 Bbb
syntax error
db > insert 2 Bbb bbb@bb.bb
data insertion completed...
db > insert 3 Ccc ccc@cc.cc cccccc
data insertion completed...
db > select
1, Aaa, aaa@aa.aa
2, Bbb, bbb@bb.bb
3, Ccc, ccc@cc.cc
data selection completed...
db > exit
program shutdown...

task:
open the file if it exists
if it does not exist create
code:
#include <stdio.h>
#include <stdlib.h>

FILE *file;

int main()
{		
	printf("open file for reading or overwriting... \n");
	file = fopen("file.txt", "r+");
	
	if(file == NULL)
	{		
		printf("create file for writing... \n");
		file = fopen("file.txt", "w");
	}
	
	return EXIT_SUCCESS;
}
output:
open file for reading or overwriting...
create file for writing...

task:
write data to file immediately without closing the program
fprintf() - writes data to buffer
fclose() - closes stream and flushes buffer data to file
fflush() - not closes stream and flushes buffer data to file
code:
#include <stdio.h>
#include <stdlib.h>

FILE *file;

int main()
{		
	printf("opening a file for writing... \n");
	file = fopen("file.txt", "w");
	
	printf("writing date to buffer... \n");
	fprintf(file, "%s", "ABC");
	
	printf("flushing data from buffer to file... \n");
	fflush(file);
	
	return EXIT_SUCCESS;
}
output:
opening a file for writing...
writing date to buffer...
flushing data from buffer to file ...
file.txt:
ABC

task:
write user data to file
display all users saved to file
overwrite user data in file
code:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

FILE *file;
void write_user_to_file();

#define PROMPT printf("db > ");
#define NAME_SIZE 32
#define EMAIL_SIZE 255
char command[100];

typedef struct
{
	int id;
	char name[NAME_SIZE];
	char email[EMAIL_SIZE];
} User;

User user[100];
int user_num = 0;
int user_size = sizeof( user[user_num] );

void add_user()
{	
	char *keyword = strtok(command, " ");
	char *id = strtok(NULL, " ");
	char *name = strtok(NULL, " ");
	char *email = strtok(NULL, " ");
	
	if(id == NULL || name == NULL || email == NULL)
	{
		printf("syntax error \n");
	}
	else
	{
		if( strlen(name) > NAME_SIZE )
		{
			printf("name is more than 32 bytes \n");
		}
		else if( strlen(email) > EMAIL_SIZE )
		{
			printf("email is more than 255 bytes \n");
		}
		else
		{			
			user_num = atoi(id);
	
			user[user_num].id = atoi(id);
			strcpy(user[user_num].name, name);
			strcpy(user[user_num].email, email);
			
			write_user_to_file();
			
			printf("data insertion completed... \n");
		}
	}
}

void write_user_to_file()
{
	fseek(file, user_num * user_size, SEEK_SET);
	
	fwrite(&user[user_num], user_size, 1, file);
	
	fflush(file);
}

void print_all_users()
{	
	rewind(file);
	
	while( fread(&user[user_num], user_size, 1, file) == 1 )
	{
		printf("%d, %s, %s \n", user[user_num].id, user[user_num].name, user[user_num].email);
	}
}

void open_file()
{
	file = fopen("file.db", "r+");
	
	if(file == NULL)
	{
		file = fopen("file.db", "w");
	}
}

int main()
{		
	open_file();

	while(true)
	{
		PROMPT;
	
		fgets(command, sizeof(command), stdin);
		/* remove '\n' from input data fgets() */
		command[strcspn(command, "\n")] = 0;
	
		if( strncmp(command, "select", 6) == 0 )
		{
			print_all_users();
			printf("data selection completed... \n");
		}
		else if( strncmp(command, "insert", 6) == 0 )
		{
			add_user();
		}
		else if( strcmp(command, "exit") == 0 )
		{
			fclose(file);
			printf("program shutdown... \n");
			exit(EXIT_SUCCESS);
		}
		else
		{
			printf("command unknown \n");
		}
	}
	
	return EXIT_SUCCESS;
}
output:
db > insert 0 aaa aaa@aaa.aa
data insertion completed...
db > insert 1 bbb bbb@bbb.bb
data insertion completed...
db > insert 2 ccc ccc@ccc.cc
data insertion completed...
output:
db > select
0, aaa, aaa@aaa.aa
1, bbb, bbb@bbb.bb
2, ccc, ccc@ccc.cc
data selection completed...
output:
db > insert 0 AAA AAA@AAA.AA
data insertion completed...
db > select
0, AAA, AAA@AAA.AA
1, bbb, bbb@bbb.bb
2, ccc, ccc@ccc.cc
data selection completed...

task:
create binary tree
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
	int key;
	struct node *left;
	struct node *rigth;
} Node;

Node *new_node(int input_key)
{
	/* memory allocation */
	Node *new = malloc( sizeof(Node) );
	
	new->key = input_key;
	new->left = NULL;
	new->rigth = NULL;
	
	return new;
}

/* declaration */
void print_tree(Node *root);

int main()
{		
	Node *root = new_node(1);
	/*
		     1
	            / \
	         NULL  NULL
	*/
	
	root->left = new_node(2);
	root->rigth = new_node(3);
	/*
		     1
	           /   \
	          2      3
	       /   \    /   \
            NULL NULL  NULL NULL
	*/
	
	root->left->left = new_node(4);
	root->rigth->rigth = new_node(5);
	/*
		     1
	           /   \
	          2      3
	       /   \    /   \
              4   NULL NULL  5
	    /  \	    /  \
          NULL  NULL      NULL  NULL
	*/
	
	print_tree(root);
	
	return EXIT_SUCCESS;
}

void print_tree(Node *root)
{
	int _root = root->key;
	
	int left = root->left->key;
	int rigth = root->rigth->key;
	
	int left_left = root->left->left->key;
	int rigth_rigth = root->rigth->rigth->key;
	
	printf("       %d	    \n", _root);
	printf("    %d    %d	    \n", left, rigth);
	printf("  %d  N  N  %d	    \n", left_left, rigth_rigth);
	printf(" N  N 	   N  N     \n");
}
output:
       1
    2    3
  4  N  N  5
N  N      N  N

task:
create binary tree with dynamic growth and sorting
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
	int key;
	struct node *left;
	struct node *rigth;
} Node;

Node *new_node(int value)
{
	Node *new = malloc( sizeof(Node) );
	
	new->key = value;
	new->left = NULL;
	new->rigth = NULL;
	
	return new;
}

Node *insert(Node *root, int value)
{
	if(root == NULL)
	{
		printf("new node key = %d \n", value);
		return new_node(value);
	}
	
	printf("value = %d, root->key = %d \n", value, root->key);
	
	if(value  >  root->key)
	{
		printf("\t\t\t left \n");
		
		root->left = insert(root->left, value);
	}
	else if(value  <  root->key)
	{	
		printf("\t\t\t rigth \n");
		
		root->rigth = insert(root->rigth, value);
	}
	
	return root;
}

int main()
{		
	Node *root = NULL;
	
	root = insert(root, 2);
/*	       2
	    /     \
	   N       N         */
	insert(root, 3);
/*	       2
	    /     \
	   3       N         */
	insert(root, 4);
/*	       2
	    /     \
	   3       N
         /  \	  
        4    N	             */
	insert(root, 1);
/*	       2
	    /     \
	   3       1
	 /  \      
	4    N               */
	return EXIT_SUCCESS;
}
output:
new node key = 2
value = 3, root->key = 2
                         left
new node key = 3
value = 4, root->key = 2
                         left
value = 4, root->key = 3
                         left
new node key = 4
value = 1, root->key = 2
                         rigth
new node key = 1

task:
print all elements of binary tree
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
	int key;
	struct node *left;
	struct node *rigth;
} Node;

Node *new_node(int value)
{
	Node *new = malloc( sizeof(Node) );
	
	new->key = value;
	new->left = NULL;
	new->rigth = NULL;
	
	return new;
}

/* declaration */
void print_node(Node *root);

int main()
{		
	Node *root = new_node(2);
	root->left = new_node(3);
	root->left->left = new_node(4);
	root->rigth = new_node(1);
/*	            2
	         /     \
	        3       1
	      /  \     /  \
	     4    N   N    N           
	   /  \
          N    N                         */
	print_node(root);
	
	return EXIT_SUCCESS;
}

void print_node(Node *root)
{
	if(root == NULL)
	{
		printf("return \n");	
		return;
	}

	printf("left ");	
	print_node(root->left);
	
	printf("%d \n", root->key);	
	
	printf("rigth ");	
	print_node(root->rigth);
}
output:
left left left return
4
rigth return
3
rigth return
2
rigth left return
1
rigth return

task:
search for element in sorted binary tree
code:
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct node
{
	int key;
	struct node *left;
	struct node *rigth;
} Node;

Node *new_node(int value)
{
	Node *new = malloc( sizeof(Node) );
	
	new->key = value;
	new->left = NULL;
	new->rigth = NULL;
	
	return new;
}

/* declaration */
bool search_node(Node *root, int key);

int main()
{		
	Node *root = new_node(20);
	root->left = new_node(30);
	root->left->left = new_node(40);
	root->left->rigth = new_node(25);
	root->rigth = new_node(10);
/*	            20
	         /      \
	        30       10
	      /   \     /   \
	    40     25  N     N	          */ 
		
	if(search_node(root, 25))
	{
		printf("\nkey found \n");
	}
	
	return EXIT_SUCCESS;
}

bool search_node(Node *root, int key)
{	
	if(root == NULL)
	{	
		printf("return \n");
		return false;
	}
	else
	{
		printf("%d ", root->key);
		
		if(key == root->key)
		{
			return true;
		}
		else if(key > root->key)
		{
			printf("left ");
			search_node(root->left, key);
		}
		else
		{
			printf("rigth ");
			search_node(root->rigth, key);
		}
	}
}
output:
20 left 30 rigth 25
key found

task:
delete element in binary search tree
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
	int key;
	struct node *left;
	struct node *right;
} Node;

Node *new_node(int value)
{
	Node *new = malloc( sizeof(Node) );
	
	new->key = value;
	new->left = NULL;
	new->right = NULL;
	
	return new;
}

/* declaration */
Node *delete_node(Node *root, int value);

int main()
{		
	Node *root = new_node(20);
	root->left = new_node(30);
	root->left->left = new_node(40);
	root->left->right = new_node(23);
	root->left->right->left = new_node(28);
	root->left->right->right = new_node(21);
	root->right = new_node(10);
	root->right->left = new_node(12);
	root->right->left->left = new_node(17);
	root->right->left->right = new_node(11);
	root->right->right = new_node(8);
/*	                  20   
                  _______/  \_______  
	         /                  \
	     ___30___             ___10___
	    /        \           /        \
	   40        23         12         8
	  	    /  \       /  \
	          28   21     17  11   
			  
40 30 28 23 21 20 17 12 11 10 8                        */
			
			
	root = delete_node(root, 20);
	printf("root = %d", root->key);
/*	                  21   
                  _______/| \_______  
	         /   left_|         \
	     ___30___   |right   ___10___
	    /        \  |right  /        \
	   40        23 |right 12         8
	  	    /  \|right/  \
		  28    X    17  11            
			  
40 30 28 23 21 17 12 11 10 8                           */
	
	return EXIT_SUCCESS;
}

Node *delete_node(Node *root, int key)
{
	if(root == NULL)
	{	
		printf("return \n");
		return root;
	}
	else
	{
		printf("%d \n", root->key);
		
		/* search for element */
		if(key > root->key)
		{
			printf("search on left - ");
			root->left = delete_node(root->left, key);
		}
		else if(key < root->key)
		{
			printf("search on right - ");
			root->right = delete_node(root->right, key);
		}
		/* element is found */
		else
		{
			/* if one child */
			if(root->left == NULL)
			{
				return root->right;
			}
			else if(root->right == NULL)
			{
				return root->left;
			}
			/* if two child */
			else
			{
				Node *temp = root->left;
				printf("left = %d \n", temp->key);
				
				while(temp->right != NULL)
				{
					printf("right = %d \n", temp->right->key);
					temp = temp->right;
				}
				
				printf("%d -> %d \n", root->key, temp->key);
				root->key = temp->key;
				
				printf("delete duplicate \n");
				root->left = delete_node(root->left, temp->key);
				
				return root;
			}
		}
	}
}
output:
20
left = 30
right = 23
right = 21
20 -> 21
delete duplicate
30
search on right - 23
search on right - 21
root = 21

task:
convert string to hash   using hash function
a = 97 b = 98 c = 99 A = 65 ascii
code:
#include <stdio.h>
#include <stdlib.h>

int string_to_hash(char *str)
{
	int hash = 10;
	int i = 0;
	
	while(*str)
	{
		printf("%d + %d = %d \n", hash, hash, hash + hash);
		hash = hash + hash;
		
		printf("%d + %d = %d \n", hash, *str, hash + *str);
		hash = hash + *str;
		
		str++;
		i++;
	}
	
	return hash;
}

int main()
{		
	printf("hash abc = %d \n", string_to_hash("abc"));
	
	printf("\n");
	
	printf("hash bac = %d \n", string_to_hash("bac"));
	
	printf("\n");
	
	printf("hash Acb = %d \n", string_to_hash("Abc"));
	
	return EXIT_SUCCESS;
}
output:
10 + 10 = 20
20 + 97 = 117
117 + 117 = 234
234 + 98 = 332
332 + 332 = 664
664 + 99 = 763
hash abc = 763

10 + 10 = 20
20 + 98 = 118
118 + 118 = 236
236 + 97 = 333
333 + 333 = 666
666 + 99 = 765
hash bac = 765

10 + 10 = 20
20 + 65 = 85
85 + 85 = 170
170 + 98 = 268
268 + 268 = 536
536 + 99 = 635
hash Acb = 635

task:
insert and search for element in hash table
with direct indexing
code:
#include <stdio.h>
#include <stdlib.h>

FILE *file;
void open_file()
{
	file = fopen("my_file.txt", "r+");
	
	if(file == NULL)
	{
		exit(EXIT_FAILURE);
	}
}

int string_to_hash(char *str)
{
	int hash = 10;
	int i = 0;
	
	while(*str)
	{
		hash = hash + hash;
		
		hash = hash + *str;
		
		str++;
		i++;
	}
	
	return hash;
}

int MAX_SIZE = 10;
int hash_key;

void search_in_hash_table(char key[])
{
	printf("\t       search \n");
	
	char result[MAX_SIZE];
	
	hash_key = string_to_hash(key);
	
	
	fseek(file, hash_key * MAX_SIZE, SEEK_SET);
	
	fread(result, MAX_SIZE, 1, file);
	

	printf("hash %d = %s \n", hash_key, result);
}

void insert_in_hash_table(char key[], char data[])
{	
	printf("\t       insert \n");
	
	hash_key = string_to_hash(key);
	
	
	printf("hash_key = %d \n", hash_key);
	
	printf("position = %d \n", hash_key * MAX_SIZE);
	

	fseek(file, hash_key * MAX_SIZE, SEEK_SET);
	
	fwrite(data, MAX_SIZE, 1, file);
}

int main()
{		
	char name[MAX_SIZE];
	char surname[MAX_SIZE];

	open_file();

	insert_in_hash_table("a", "one");
	insert_in_hash_table("b", "two");
	
	search_in_hash_table("a");
	search_in_hash_table("b");
	
	fclose(file);
	
	return EXIT_SUCCESS;
}
output:
               insert
hash_key = 117
position = 1170
               insert
hash_key = 118
position = 1180
               search
hash 117 = one
               search
hash 118 = two

task:
binary search tree balancing / left rotation
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct Node
{
	int key;
	struct Node *left;
	struct Node *right;
} Node;

Node *new_node(int key)
{
	Node *node = malloc( sizeof(Node) );
	
	node->key = key;
	node->left = NULL;
	node->right = NULL;
	
	return node;
}

Node *left_rotation(Node *ORIGINAL)
{
////////////////////////////////////////////////
/*                  10             ORIGINAL TREE
	           /  \
	          5   20      
	             /  \       
	            15  30               
		        | \
	                25 40                  */
////////////////////////////////////////////////					  
	Node *ONE = ORIGINAL->right;
/*                    20                ONE TREE
	             /  \ 
                    15  30   
	                | \
	                25 40                  */
////////////////////////////////////////////////
	Node *TWO = ORIGINAL->right->left;
/*                  15                  TWO TREE
                   /  \
	          N    N                       */
////////////////////////////////////////////////	
	ONE->left = ORIGINAL;
/*                    20                ONE TREE
	             /  \ 
     ORIGINAL TREE->10  30   
	           / \   | \
	          5  20  25 40
		     / \
		    15 30
		       / \
		      25 40                    */
////////////////////////////////////////////////		      
	ONE->left->right = TWO;
/*                    20                ONE TREE
	             /  \ 
     ORIGINAL TREE->10  30   
	           / \   | \
	          5  15< 25 40
		     /\<-TWO TREE
		    N  N                       */
////////////////////////////////////////////////
	return ONE;
}

int main()
{		
	Node *root = NULL;

	root = new_node(10);
	root->left = new_node(5);
	root->right = new_node(20);
	root->right->left = new_node(15);
	root->right->right = new_node(30);
	root->right->right->left = new_node(25);
	root->right->right->right = new_node(40);
/*                    10
	             /  \
	            5   20      
	               /  \       
	              15  30               
		          | \
	                  25 40                */
	root = left_rotation(root);
	
	printf("%d ", root->key);
	printf("%d ", root->left->key);
	printf("%d ", root->left->right->key);

	return EXIT_SUCCESS;
}
output:
20 10 15

task:
binary search tree balancing / right rotation
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct Node
{
	int key;
	struct Node *left;
	struct Node *right;
} Node;

Node *new_node(int key)
{
	Node *node = malloc( sizeof(Node) );
	
	node->key = key;
	node->left = NULL;
	node->right = NULL;
	
	return node;
}

Node *right_rotation(Node *ORIGINAL)
{
////////////////////////////////////////////////
/*                   30           ORIGINAL TREE
		    /  \
		   20   40
		  /  \
		 10   25
		/ \
	       5   15                          */
////////////////////////////////////////////////
	Node *ONE = ORIGINAL->left;
/*                 20                  ONE TREE
		  /  \
		 10   25
		/ \
	       5  15                           */
////////////////////////////////////////////////
	Node *TWO = ORIGINAL->left->right;
/*                    25               TWO TREE
                     /  \
		    N    N                     */
////////////////////////////////////////////////
	ONE->right = ORIGINAL;
/*                 20                  ONE TREE
		  /  \
		10    30<-ORIGINAL TREE
	       / \    / \
	      5  15  20  40
	            / \
                   10  15
		  / \
		 5  15                         */
////////////////////////////////////////////////
	ONE->right->left = TWO;
/*                 20                  ONE TREE
		  /  \
		10    30<-ORIGINAL TREE
	       / \    / \
	      5  15  25< 40
		    / \<-TWO TREE 
                   N   N                       */
////////////////////////////////////////////////
	return ONE;
}

int main()
{		
	Node *root = NULL;

	root = new_node(30);
	root->right = new_node(40);
	root->left = new_node(20);
	root->left->right = new_node(25);
	root->left->left = new_node(10);
	root->left->left->right = new_node(15);
	root->left->left->left = new_node(5);
/*                   30
		    /  \
		   20   40
		  /  \
		 10   25
		/ \
	       5   15                      */
	
	root = right_rotation(root);
	
	printf("%d ", root->key);
	printf("%d ", root->right->key);
	printf("%d ", root->right->left->key);

	return EXIT_SUCCESS;
}
output:
20 30 25

task:
binary search tree balancing / left + right rotation
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct Node
{
	int key;
	struct Node *left;
	struct Node *right;
} Node;

Node *new_node(int key)
{
	Node *node = malloc( sizeof(Node) );
	
	node->key = key;
	node->left = NULL;
	node->right = NULL;
	
	return node;
}

Node *right_rotation(Node *ORIGINAL)
{
////////////////////////////////////////////////
/*                        50       ORIGINAL TREE
			 /  \
		        30  60
		       /  \
		      10  40
		     / \
		    5  20                      */
////////////////////////////////////////////////			
	Node *ONE = ORIGINAL->left;
/*                      30              ONE TREE
		       /  \
		      10  40
		     / \
	            5  20                      */
////////////////////////////////////////////////
	Node *TWO = ORIGINAL->left->right;
/*                        40            TWO TREE
                         /  \ 
			N    N                 */
////////////////////////////////////////////////
	ONE->right = ORIGINAL;
/*                      30              ONE TREE
		       /  \
		     10    50<-ORIGINAL TREE
	            / \    / \
		   5  20  30  60
		         / \
			10  40
		       / \
		      5  20                    */
////////////////////////////////////////////////
    ONE->right->left = TWO;
/*                      30              ONE TREE
		       /  \
		     10    50<-ORIGINAL TREE
		    / \    / \
		   5  20  40< 60
                          /\<-TWO TREE
			 N  N                  */
////////////////////////////////////////////////
	return ONE;
}


Node *left_rotation(Node *ORIGINAL)
{
////////////////////////////////////////////////
/*                  10             ORIGINAL TREE   
	           /  \
		  5    30
		      /  \
		     20  40                    */
////////////////////////////////////////////////
	Node *ONE = ORIGINAL->right;
/*                     30               ONE TREE
		      /  \
		     20  40                    */
////////////////////////////////////////////////
	Node *TWO = ORIGINAL->right->left;
/*                   20                 TWO TREE    
                    /  \
	           N    N                      */
////////////////////////////////////////////////
	ONE->left = ORIGINAL;
/*                      30              ONE TREE
	               /  \
       ORIGINAL TREE->10  40
		     / \
		    5  30
		       / \
		     20  40                    */
////////////////////////////////////////////////
	ONE->left->right = TWO;
/*                     30               ONE TREE
		      /  \
      ORIGINAL TREE->10  40
		    / \
		   5  20<-TWO TREE
		      / \
		     N   N                     */
////////////////////////////////////////////////
	return ONE;
}

int main()
{		
	Node *root = NULL;
	
	root = new_node(50);
	root->right = new_node(60);
	root->left = new_node(10);
	root->left->right = new_node(30);
	root->left->left = new_node(5);
	root->left->right->left = new_node(20);
	root->left->right->right = new_node(40);
/*                        50
		         /  \
			10  60
		       /  \
		      5    30
			  /  \
		         20  40                */
////////////////////////////////////////////////
	root->left = left_rotation(root->left);
/*                        50  
		         /  \
			30  60
		       /  \
		      10  40
		     / \
	            5  20                      */
////////////////////////////////////////////////
	root = right_rotation(root);
/*			30  
		       /  \
		     10    50
		    / \    / \
	           5  20  40  60               */
////////////////////////////////////////////////
			   
	printf("%d ", root->key);
	printf("%d ", root->right->key);
	printf("%d ", root->right->left->key);

	return EXIT_SUCCESS;
}
output:
30 50 40

task:
binary search tree balancing / right + left rotation
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct Node
{
	int key;
	struct Node *left;
	struct Node *right;
} Node;

Node *new_node(int key)
{
	Node *node = malloc( sizeof(Node) );
	
	node->key = key;
	node->left = NULL;
	node->right = NULL;
	
	return node;
}

Node *left_rotation(Node *ORIGINAL)
{
////////////////////////////////////////////////
/*		      10           ORIGINAL TREE
		     /  \
		    5    30
		        /  \
		       20  40 
                          /  \
			 35  50                */
////////////////////////////////////////////////
	Node *ONE = ORIGINAL->right;
/*	                 30             ONE TREE
			/  \
		       20  40 
                          /  \
		         35  50                */
////////////////////////////////////////////////
	Node *TWO = ORIGINAL->right->left;
/*                     20               TWO TREE
                      /  \
		     N    N                    */
////////////////////////////////////////////////
	ONE->left = ORIGINAL;
/*	                 30             ONE TREE
			/  \
       ORIGINAL TREE->10    40 
                     / \    / \
	            5  30  35 50
		      /  \
		     20  40
		        /  \
		       35  50                  */
////////////////////////////////////////////////
	ONE->left->right = TWO;
/*	                 30             ONE TREE
			/  \
       ORIGINAL TREE->10    40 
                     / \    / \
		    5  20< 35 50
		       /\<-TWO TREE
	              N  N                     */
////////////////////////////////////////////////
	return ONE;
}

Node *right_rotation(Node *ORIGINAL)
{
////////////////////////////////////////////////
/*                       40        ORIGINAL TREE
			/  \
		       30  50 
                      /  \
		     20  35                    */
////////////////////////////////////////////////
	Node *ONE = ORIGINAL->left;
/*                     30               ONE TREE
                      /  \
		     20  35                    */
////////////////////////////////////////////////
	Node *TWO = ORIGINAL->left->right;
/*                       35             TWO TREE
                        /  \
		       N    N                  */
////////////////////////////////////////////////
	ONE->right = ORIGINAL;
/*                     30               ONE TREE
                      /  \
		     20  40<-ORIGINAL TREE
		        /  \
		       30  50
		      /  \
		     20  35                    */
////////////////////////////////////////////////
	ONE->right->left = TWO;
/*                     30               ONE TREE
                      /  \
                     20  40<-ORIGINAL TREE
                        /  \
                       35< 50   
                      / \<-TWO TREE	
                     N   N                     */
////////////////////////////////////////////////
	return ONE;
}

int main()
{		
	Node *root = NULL;
	
	root = new_node(10);
	root->left = new_node(5);
	root->right = new_node(40);
	root->right->left = new_node(30);
	root->right->right = new_node(50);
	root->right->left->right = new_node(35);
	root->right->left->left = new_node(20);
/*		      10
		     /  \
		    5    40
		        /  \
		       30  50 
                      /  \
		     20  35                    */
////////////////////////////////////////////////
	root->right = right_rotation(root->right);
/*		      10
	   	     /  \
		    5    30
		        /  \
		       20  40 
                          /  \
			 35  50                */
////////////////////////////////////////////////
	root = left_rotation(root);
/*		         30
			/  \
		      10    40 
                     / \    / \
		    5  20  35  50              */
////////////////////////////////////////////////
				
	printf("%d ", root->key);
	printf("%d ", root->right->key);
	printf("%d ", root->right->left->key);

	return EXIT_SUCCESS;
}
output:
30 40 35

task:
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct Node
{
    int key;
    int height;
    struct Node *left;
    struct Node *right;
} Node;

Node *new_node(int key)
{
    Node *node = malloc( sizeof(Node) );
    
    node->key = key;
    node->left = NULL;
    node->right = NULL;
    
    return node;
}

Node *right_rotation(Node *ORIGINAL)
{
    Node *ONE = ORIGINAL->left;
    Node *TWO = ORIGINAL->left->right;

    ONE->right = ORIGINAL;
    ONE->right->left = TWO;

    return ONE;
}

int max(int one, int two)
{
    if(one > two)
    {
        return one;
    }
    return two;
}

int height(Node *node)
{
    if(node == NULL)
    {
        return 0;
    }
    return node->height;
}

int get_balance(Node *node)
{
    if(node == NULL)
    {
        return 0;
    }
    return height(node->left) - height(node->right);
}

Node *insert(Node *node, int key)
{
    if(node == NULL)
    {
        printf("key = %d, new node \n", key);
        return new_node(key);
    }
    
    printf("key = %d, node->key = %d \n", key, node->key);
    
    if(key  >  node->key)
    {
        printf("right ");
        node->right = insert(node->right, key);
    }
    else if(key  < node->key)
    {
        printf("left ");
        node->left = insert(node->left, key);
    }
    
    
    node->height = 1 + max( height(node->left), height(node->right) );
    
    printf("h%d nodekey%d \n", node->height, node->key);
    
    
    int balance = get_balance(node);
    
    printf("balance %d \n", balance);
    
    
    if(balance > 1)
    {
        printf("rotation \n");
        return right_rotation(node);
    }
    
    return node;
}

int main()
{    
    Node *root = NULL;
    
    root = insert(root, 40);
/*
    height = 0      40    
                   /  \
                  N    N
*/
    root = insert(root, 30);
/*
    h1              40     balance h0 - h0
                   /  \
    h0           30    N  
*/
    root = insert(root, 20);
/*
    h2              40     balance h1 - h0
                   /  \
    h1           30    N
                /
    h0        20
*/
    root = insert(root, 10);
/*
    h3              40     balance h2 - h0 (unbalanced)
                   /  \
    h2           30    N
                /
    h1        20
             /
    h0      10
*/
/*                         right rotation
                    30
                   /  \
                 20    40
                /
              10
*/
    printf("%d ", root->key);
    printf("%d ", root->left->key);
    printf("%d ", root->left->left->key);
    printf("%d ", root->right->key);
    
    return EXIT_SUCCESS;
}
output:
key = 40, new node
key = 30, node->key = 40
left key = 30, new node
h1 nodekey40
balance 0
key = 20, node->key = 40
left key = 20, node->key = 30
left key = 20, new node
h1 nodekey30
balance 0
h2 nodekey40
balance 1
key = 10, node->key = 40
left key = 10, node->key = 30
left key = 10, node->key = 20
left key = 10, new node
h1 nodekey20
balance 0
h2 nodekey30
balance 1
h3 nodekey40
balance 2
rotation
30 20 10 40

task:
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct Node
{
    int key;
    int height;
    struct Node *left;
    struct Node *right;
} Node;

Node *new_node(int key)
{
    Node *node = malloc( sizeof(Node) );
    
    node->key = key;
    node->left = NULL;
    node->right = NULL;
    
    return node;
}

Node *left_rotation(Node *ORIGINAL)
{
    Node *ONE = ORIGINAL->right;
    Node *TWO = ORIGINAL->right->left;
    
    ONE->left = ORIGINAL;
    ONE->left->right = TWO;

    return ONE;
}

int max(int one, int two)
{
    if(one > two)
    {
        return one;
    }
    return two;
}

int height(Node *node)
{
    if(node == NULL)
    {
        return 0;
    }
    return node->height;
}

int get_balance(Node *node)
{
    if(node == NULL)
    {
        return 0;
    }
    return height(node->left) - height(node->right);
}

Node *insert(Node *node, int key)
{
    if(node == NULL)
    {
        printf("key = %d, new node \n", key);
        return new_node(key);
    }
    
    printf("key = %d, node->key = %d \n", key, node->key);
    
    if(key  >  node->key)
    {
        printf("right ");
        node->right = insert(node->right, key);
    }
    else if(key  < node->key)
    {
        printf("left ");
        node->left = insert(node->left, key);
    }
    
    
    node->height = 1 + max( height(node->left), height(node->right) );
    
    printf("h%d nodekey%d \n", node->height, node->key);
    
    
    int balance = get_balance(node);
    
    printf("balance %d \n", balance);
    
    
    if(balance < -1)
    {
        printf("rotation \n");
        
        return left_rotation(node);
    }
    
    return node;
}

int main()
{    
    Node *root = NULL;
    
    root = insert(root, 10);
/*
            10             height = 0
           /  \
          N    N
*/
    root = insert(root, 20);
/*
            10 h1          balance h0 - h0
           /  \
          N    20 h0
*/
    root = insert(root, 30);
/*
            10 h2          balance h0 - h1
           /  \
          N    20 h1     
                 \
                  30 h0
*/
    root = insert(root, 40);
/*
            10 h3          balance h0 - h2
           /  \
          N    20 h2     
                 \
                  30 h1  
                    \
                     40 h0
*/
/*                         left rotation
                  20
                 /  \
               10    30	
                       \
                        40  
*/
	printf("%d ", root->key);
	printf("%d ", root->left->key);
	printf("%d ", root->right->key);
	printf("%d ", root->right->right->key);
    
    return EXIT_SUCCESS;
}
output:
key = 10, new node
key = 20, node->key = 10
right key = 20, new node
h1 nodekey10
balance 0
key = 30, node->key = 10
right key = 30, node->key = 20
right key = 30, new node
h1 nodekey20
balance 0
h2 nodekey10
balance -1
key = 40, node->key = 10
right key = 40, node->key = 20
right key = 40, node->key = 30
right key = 40, new node
h1 nodekey30
balance 0
h2 nodekey20
balance -1
h3 nodekey10
balance -2
rotation
20 10 30 40

task:
code:


---
task:
code:
#include <stdio.h>
#include <stdlib.h>

typedef struct Btree
{

} Btree;

void insert_in_btree(int input_value)
{
	
}

int main()
{	
	insert_in_btree(55);
	
	return EXIT_SUCCESS;
}



































































































